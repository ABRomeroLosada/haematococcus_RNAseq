---
title: "Script comentado usado para el análisis RNA-seq de *Haematococcus pluviasis*"
author: "Ana Belén Romero-Losada, Francisco J. Romero-Campero"
date: "July, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Used packages. 

Call the packages that are used in this script. *FactoMineR* and *factoextra* are used in multivariant analyses such as Principal Component Analyses and hierarchical clustering, while *ballgown* and *limma* packages are used to read the transcriptomic data and to execute the differential expression analysis. 

Additionally, *clusterProfiler* and *pathview* are used to perform enrichment analyses in GO terms and metabolic pathways in KEGG, respectively. 

```{r, echo= TRUE, results = 'hide'}

library(FactoMineR)
library(factoextra)
library(ballgown)
library(limma)
library(clusterProfiler)
library(pathview)


```

#Read transcriptomic data and generate Ballgown object. 

As it is mentioned before, the package *ballgown* is used to load transcriptomic results in R and to generate a ballgown object that contains all the information. To generate the mentioned ballgown object is needed: a **CSV** file containing experimental design and all the **ctabs** files generated in the previous steps of the computational analysis (when *hisat2* and *stringtie* had been used).

```{r, echo = TRUE, eval = FALSE}

experimental.design <- read.csv("experimental_design.csv",as.is=T)
experimental.design$sample

bg.data <- ballgown(dataDir = ".", samplePattern = "sample", pData=experimental.design)

```

Expression levels of DEGs can be extracted from the ballgown object (using the *gexpr* function from **ballgown**) and they can be saved in a **TSV** file after passing by a manually clean up. 

```{r, echo= TRUE, eval = FALSE}

gene.expression <- gexpr(bg.data)

```

Columns of the matrix generated are named with a explanatory name corresponding to the different conditions of the study. 

```{r, echo= TRUE, eval = FALSE}

colnames(gene.expression) <- c("NO3_4mM_1","NO3_4mM_2","NO3_12mM_1","NO3_12mM_2")

```

During the clean up steps two decisions are made. First, all the genes that never seems to be expressed are removed. 

```{r, echo= TRUE, eval = FALSE}

gene.expression <- gene.expression[apply(X = gene.expression,MARGIN = 1,sum) != 0,]

```

Second, all the noisy genes that show very different expression levels between replicates are also removed.

```{r, echo= TRUE, eval = FALSE}

gene.expression <- gene.expression[!(((gene.expression[,"NO3_4mM_1"] == 0 & gene.expression[,"NO3_4mM_2"] > 0) | (gene.expression[,"NO3_4mM_1"] > 0 & gene.expression[,"NO3_4mM_2"] == 0)) |
                                     ((gene.expression[,"NO3_12mM_1"] == 0 & gene.expression[,"NO3_12mM_2"] > 0) | (gene.expression[,"NO3_12mM_1"] > 0 & gene.expression[,"NO3_12mM_2"] == 0))),]

```


Finally, the *TSV* file is generated and from this moment, everytime that we want to run the script we can directly read this file instead of all the transcriptomic data, reducing computational effort.


```{r, echo = TRUE, eval = FALSE}

write.table(x = gene.expression,file = "haematococcus_gene_expression.tsv",
            quote = F,sep = "\t")

```


#Principal Components Analysis and hierarchical clustering.

In Principal Components Analyses (PCA) new variables are defined corresponding to a linear combination of the original ones. In this way, PCA decreases the dimensionality of data in a multivariate study facilitating graphical visualization of them. 

In the following code a Principal Components Analysis of transcriptomic data is executed with the function **PCA** (íncluded in *FactoMineR*). This function expects a data frame which columns are numeric variables, so a transposed of our gene expression data frame is needed. 

```{r, echo = TRUE, eval = TRUE}

gene.expression <- read.table(file = "haematococcus_gene_expression.tsv",
                              header = T,sep = "\t")

pca.gene.expression <- data.frame(colnames(gene.expression),t(gene.expression))
colnames(pca.gene.expression)[1] <- "Sample"

res.pca <- PCA(pca.gene.expression, graph = FALSE,scale.unit = TRUE,quali.sup = 1 )

```

Hierarchical clustering is one of the most common clustering strategies. Different clusters (i.e. groups) are identified by this clustering strategy based on similarity.
Combined with PCA can lead to the identification of more stable clusters, due to the noise reduction achieved with PCA. 

In this way, the **HCPC** function (included in *FactoMineR* package) is applied on the previous PCA results. 

```{r, echo = TRUE, eval = TRUE}

res.hcpc <- HCPC(res.pca, graph=FALSE, nb.clust = 2)    

```

After that, the graphical visualization of the results is generated using the function **fviz_bend** included in *factoextra* package.

```{r, echo = TRUE, eval = TRUE}

fviz_dend(res.hcpc,k=3,
          cex = 1,                       # Label size
          palette = "jco",               # Color palette
          rect = TRUE, rect_fill = TRUE, # Add rectangle around groups
          rect_border = "jco",           # Rectangle color
          type="rectangle",
          labels_track_height = 4500      # Augment the room for labels
)

```

This graph shows how the two replicates of each condition are highly similar to each other, so they are included in the same cluster, which is different from the cluster of the other condition. 

The similarity between replicates can be also represented using tipycal scatter plots. Here we represent two different scatter plots, one for each condition. 

```{r, echo = TRUE, eval = TRUE}

lowN <- rowMeans(gene.expression[,1:2])
highN <- rowMeans(gene.expression[,3:4])

plot(log2(gene.expression[,1]+1),log2(gene.expression[,2]+1),pch=19,cex=0.7,xlab="NO3_4mM_1",ylab="NO3_4mM_2",col="darkgrey",cex.lab=1.5)
lines(x=c(-1,20),y=c(-1,20),col="red",lwd=3)
text(x = 2,y=11,labels = paste(round(100*cor(log2(gene.expression[,1]+1),log2(gene.expression[,2]+1)),digits=2),"%"),cex=1.5)

plot(log2(gene.expression[,3]+1),log2(gene.expression[,4]+1),pch=19,cex=0.7,xlab="NO3_12mM_1",ylab="NO3_12mM_2",col="darkgrey",cex.lab=1.5)
lines(x=c(-1,20),y=c(-1,20),col="red",lwd=3)
text(x = 2,y=11,labels = paste(round(100*cor(log2(gene.expression[,3]+1),log2(gene.expression[,4]+1)),digits=2),"%"),cex=1.5)

```

Both graphs show that replicates of the same condition are highly correlated with a correlation coefficient of 99.29% for low N samples and 96.4% for high N samples.

Otherwise, when the two conditions are represented in a scatter plot a global gene repression is observed. 

```{r, echo = TRUE, eval = TRUE}

plot(log2(highN+1),log2(lowN+1),pch=19,cex=0.7,xlab="12mM",ylab="4mM",xlim=c(0,15),ylim=c(0,15),col="darkgrey",cex.lab=1.5)
lines(x=c(-1,20),y=c(-1,20),col="red",lwd=3)

```


#Differential expression analysis.  

The first step in a differential expression analysis is the specification of the experimental design. It is indicated in a factorial way, meaning that the first condition is represented by the number 1 and the second one by the number 2. In that way, for example, there are as many 1 as there are replicates of the first condition.

```{r, echo = TRUE, eval = TRUE}

factor.experimental.design <- c(1,1,2,2)
limma.experimental.design <- model.matrix(~ -1+factor(factor.experimental.design))
colnames(limma.experimental.design) <- c("NO3_4mM", "NO3_12mM")

```

Then, the stimated gene expression levels of each gene are adjusted to a linear model (using the **lmFit** function included in *limma*) considering the experimental design specificated.

```{r, echo = TRUE, eval = TRUE}

log.gene.expression <- log2(gene.expression+1)

linear.fit <- lmFit(log.gene.expression, limma.experimental.design)

```

The contrast that will be performed is indicated using **makeContrast** function, and the fold change and p-value are calculated with the functions **constrasts.fit** and **eBayes**. 

```{r, echo = TRUE, eval = TRUE}

contrast.matrix <- makeContrasts(NO3_4mM-NO3_12mM,
                                 
                                 levels=c("NO3_4mM", "NO3_12mM"))

contrast.linear.fit <- contrasts.fit(linear.fit, contrast.matrix)
contrast.results <- eBayes(contrast.linear.fit)

```

Finally, using the **topTable** function, the results from the differential expressed genes analysis can be extracted.

```{r, echo = TRUE, eval = TRUE}

degs.results <- topTable(contrast.results, number=nrow(log.gene.expression),coef=1,sort.by="logFC")
head(degs.results)

```

To interpret the results in a easier way, the activated and repressed genes can be identificated considering a q-value and fold change treshold. In this case, the fold change treshold selected is 2 and the q-value treshold is 0.05.

```{r, echo = TRUE, eval = TRUE}

fold.change <- degs.results$logFC
p.values <- degs.results$P.Value
q.values <- degs.results$adj.P.Val
genes.ids <- rownames(degs.results)

names(fold.change) <- genes.ids
names(q.values) <- genes.ids
names(p.values) <- genes.ids

fc.threshold <- 2
q.val.threshold <- 0.05

activated.genes <- genes.ids[fold.change > log2(fc.threshold) & q.values < q.val.threshold]
repressed.genes <- genes.ids[fold.change < - log2(fc.threshold) & q.values < q.val.threshold]

length(activated.genes)
length(repressed.genes)

```

Considering the selected tresholds, the number of activates genes is 505 and the number of repressed genes is 5603. This results can be represented in a volcano plot. 

```{r, echo = TRUE, eval = TRUE}

log10.qval <- -log10(q.values)
log10.pval <- -log10(p.values)

plot(fold.change,log10.qval,pch=19,cex=0.7,col="grey", xlab="Fold Change", ylab="-log10(p-value)",cex.lab=1.5)
points(fold.change[activated.genes],log10.qval[activated.genes],cex=0.7,col="red",pch=19)
points(fold.change[repressed.genes],log10.qval[repressed.genes],cex=0.7,col="blue",pch=19)

```



