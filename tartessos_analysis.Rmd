---
title: "Script used for tartessos analysis explained step by step."
author: "Ana Bel√©n Romero-Losada, Francisco J. Romero-Campero"
date: "Feb, 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Used packages. 

Load the packages that are used in this script. Several Bioconductor packages are used, such as *ballgown* and *limma* packages for reading the transcriptomic data and for executing the differential expression analysis, or *clusterProfiler* and *pathview* for performing enrichment analyses in GO terms and metabolic pathways in KEGG, respectively. 


```{r, echo= TRUE, results = FALSE, message=FALSE, warning=FALSE}

library(ballgown)
library(limma)
library(clusterProfiler)
library(pathview)

```

Additionally, two CRAN packages are required for executing this script: ggplots and seqinr. Ggplots will be used to generate certain plots and seqinr is required to work with biological sequences. 

```{r, echo= TRUE, results = FALSE, message=FALSE, warning=FALSE}

library(gplots)
library(seqinr)

```

Finally, the annotation packages included in tartessos_RNAseq github folder need to be installed and loaded before starting the analysis. 

```{r, echo= TRUE, results = FALSE, message=FALSE, warning=FALSE}

install.packages("packages/org.Hlacustris.eg.db",repos = NULL)
install.packages("packages/TxDb.Hlacustris.NCBI",repos = NULL)
library(org.Hlacustris.eg.db)
library(TxDb.Hlacustris.NCBI)

```


# Load genome sequence data 

Sequences and their names will be extracted from *haematococcus_lacustris.fa* which contains the sequenced genome of **Haematococcus lacustris**.

```{r, echo = TRUE, eval = TRUE}

hlacustris.info <- read.fasta(file = "haematococcus_lacustris.fa",seqtype = "DNA")
hlacustris.seqs <- getSequence(hlacustris.info)
names(hlacustris.seqs) <- getName(hlacustris.info)


```

Gene names are extracted from TxDb package and all the information is gathered in the same data frame.

```{r, echo = TRUE, eval = TRUE}

txdb <- TxDb.Hlacustris.NCBI
hlacustris.genes <- as.data.frame(genes(txdb))

```


# Differential expression analysis.  

Before starting the analysis, gene expression data has to be loaded.

```{r, echo = TRUE, eval = TRUE}

gene.expression.data <- read.table(file = "gene_expression.tsv",header = T,sep = "\t")
gene.expression <- as.matrix(gene.expression.data[,2:5])
rownames(gene.expression) <- gene.expression.data$Gene
log.gene.expression <- log2(gene.expression+1)
head(log.gene.expression)

```

The first step in a differential expression analysis is the specification of the experimental design. It is indicated in a factorial way, meaning that the first condition is represented by the number 1 and the second one by the number 2. In that way, for example, there are as many 1 as there are replicates of the first condition.

```{r, echo = TRUE, eval = TRUE}

factor.experimental.design <- c(1,1,2,2)
limma.experimental.design <- model.matrix(~ -1+factor(factor.experimental.design))
colnames(limma.experimental.design) <- c("NO3_2mM", "NO3_15mM")

```

Then, the stimated gene expression levels of each gene are adjusted to a linear model (using the **lmFit** function included in *limma*) considering the experimental design specificated.

```{r, echo = TRUE, eval = TRUE}

linear.fit <- lmFit(log.gene.expression, limma.experimental.design)

```

The contrast that will be performed is indicated using **makeContrast** function, and the fold change and p-value are calculated with the functions **constrasts.fit** and **eBayes**. 

```{r, echo = TRUE, eval = TRUE}

contrast.matrix <- makeContrasts(NO3_2mM-NO3_15mM,
                                 levels=c("NO3_2mM", "NO3_15mM"))

contrast.linear.fit <- contrasts.fit(linear.fit, contrast.matrix)
contrast.results <- eBayes(contrast.linear.fit)

```

Finally, using the **topTable** function, the results from the differential expressed genes analysis can be extracted.

```{r, echo = TRUE, eval = TRUE}

degs.results <- topTable(contrast.results, number=nrow(log.gene.expression),coef=1,sort.by="logFC")
head(degs.results)

```

To interpret the results in a easier way, the activated and repressed genes can be identificated considering a q-value and fold change treshold. In this case, the fold change treshold selected is 2 and the q-value treshold is 0.05.

```{r, echo = TRUE, eval = TRUE}

fold.change <- degs.results$logFC
q.values <- degs.results$adj.P.Val
genes.ids <- rownames(degs.results)

names(fold.change) <- genes.ids
names(q.values) <- genes.ids

fc.threshold <- 2
q.val.threshold <- 0.05

activated.genes <- genes.ids[fold.change > log2(fc.threshold) & q.values < q.val.threshold]
repressed.genes <- genes.ids[fold.change < - log2(fc.threshold) & q.values < q.val.threshold]

length(activated.genes)
length(repressed.genes) 

```

Considering the selected tresholds, the number of activates genes is 414 and the number of repressed genes is 5348. This results can be represented in a volcano plot. 

```{r, echo = TRUE, eval = TRUE}

log10.qval <- -log10(q.values)

plot(fold.change,log10.qval,pch=19,cex=0.5,col="grey",
     xlim=c(-15,15), ylim=c(0,3),
     xlab="Log2 Fold Change", ylab="-log10(q-value)",cex.lab=1.5)
points(fold.change[activated.genes],log10.qval[activated.genes],cex=0.7,col="red",pch=19)
points(fold.change[repressed.genes],log10.qval[repressed.genes],cex=0.7,col="blue",pch=19)

```


# Correspondence between genome notation and NCBI notation.

Genome notation doesn't match with NCBI notation, which can lead to confusion at some steps of the analysis. 

```{r, echo = TRUE, eval = TRUE}

halan.gfh.correspondence <- read.table(file="gfh_halan_correspondence.tsv",sep="\t",as.is=T)
head(halan.gfh.correspondence)

halan <- halan.gfh.correspondence$V2
gfh <- halan.gfh.correspondence$V1
names(halan) <- gfh
names(gfh) <- halan

```

# KEEG pathway enrichment

KO ids are extracted from *org.Hlacustris.eg.db*.

```{r, echo = TRUE, eval = TRUE}

hlac.ko <- select(org.Hlacustris.eg.db,columns = c("KO"),keys=keys(org.Hlacustris.eg.db,keytype = "GID"))
ko.universe <- hlac.ko$KO
ko.universe <- ko.universe[!is.na(ko.universe)]

```

Activated and repressed genes are gathered with their corresponding KO id.

```{r, echo = TRUE, eval = TRUE}

activated.target.ko <- subset(hlac.ko,GID %in% gfh[activated.genes])$KO
activated.target.ko <- activated.target.ko[!is.na(activated.target.ko)]

repressed.target.ko <- subset(hlac.ko,GID %in% gfh[repressed.genes])$KO
repressed.target.ko <- repressed.target.ko[!is.na(repressed.target.ko)]

```

Now the enrichment can be achieved using the **enrichKEGG** function included in *pathway* package. The results are represented in a simple barplot. Additionally, the results can be saved in a **.txt** file.
 
```{r, echo = TRUE, eval = TRUE}

pathway.enrichment <- enrichKEGG(gene = activated.target.ko, organism = "ko", 
                                 universe = ko.universe,qvalueCutoff = 0.05)

barplot(height = pathway.enrichment,showCategory = 11)

write.table(x = as.data.frame(pathway.enrichment),
            file = "pathway_enrichment/pathway_activated.tsv",
            quote = F,sep = "\t",row.names = F)

```

## Graphical representation of pathways

At first place, a new variable called *genes.pathway* is defined. Each element of this variable correspond to a different gene and it will contain a different number depending on whether or not that gene is activated. The value -1 will be given to repressed genes, +1 to activated ones and 0 to neutral ones. 

```{r, echo = TRUE, eval = TRUE}

genes.pathway <- rep(0, length(ko.universe))
names(genes.pathway) <- ko.universe

genes.pathway[activated.target.ko] <- 1
genes.pathway[repressed.target.ko] <- -1

```

Then this variable can be used to generate the desirable KEGG pathway (for example ko00906) where the enzimes that correspond to activated and repressed genes will be colored differently.

```{r, echo = TRUE, eval = TRUE}

pathview(gene.data = sort(genes.pathway,decreasing = TRUE),
         kegg.dir ="pathway_enrichment/", pathway.id = "ko00906",
         species = "ko",
         limit = list(gene=max(abs(genes.pathway)), cpd=1))

```


# Identification of transcription factors and promoter sequences. 

## Identification of transcription factor genes aspirants.

In order to make the analysis easier, a simple function is created to extract the genes which PFAM id match with the target one. 

```{r, echo = TRUE, eval = TRUE}

extract.tf <- function(annotation, pfam.id)
{
  return(unique(subset(annotation,PFAM == pfam.id)$GENES))
}

```

The PFAM ids that correspond to each gene are gathered in the annotation file, so it needs to be loaded.

```{r, echo = TRUE, eval = TRUE}

haematococcus.annotation <- read.table(file = "haematoccocus_functional_annotation.csv",
                                       header = T,as.is = T,fill = T)
                                       
```

Then, the PFAM corresponding to the the target transcription factor is searched manually. For example, PF00847 corresponds the AP2 transcription factors family, so it is used to find the genes inside haematococcus genome that can belong to this family.

```{r, echo = TRUE, eval = TRUE}

AP2.genes <- extract.tf(annotation = haematococcus.annotation,pfam.id = "PF00847")
AP2.genes
length(AP2.genes)

```

However, it can also be interesting to find out if any of the AP2 transcription factors family aspirants genes is activated or repressed under our experiment conditions. 

```{r, echo = TRUE, eval = TRUE}

ap2.activated <- length(intersect(activated.genes, halan[AP2.genes]))
ap2.repressed <- length(intersect(repressed.genes, halan[AP2.genes]))
ap2.non.diff <- length(AP2.genes) - ap2.activated - ap2.repressed

```

This analysis is executed to all the possible transcription factors families.


# Extraction of promoter sequences of targets genes.

The following function is used to achieve that goal. To a given list of gene names, it extracts their promoter sequences (1000 bp upstream from TSS) using the sequenced genome.

```{r, echo = TRUE, eval = TRUE}

promoter.sequence <- function(genes.names, genes.info, genome.seqs,file.name)
{
  genes.of.interest <- subset(genes.info, gene_id %in% genes.names)
  
  promoter.seqs <- vector(mode="list",length=nrow(genes.of.interest))
  names(promoter.seqs) <- genes.of.interest$gene_id
  
  for(i in 1:nrow(genes.of.interest))
  {
    current.seq.id <- as.character(genes.of.interest$seqnames[i])
    current.seq <- genome.seqs[current.seq.id]
    current.strand <- as.character(genes.of.interest$strand[i])
    
    if(current.strand == "+")
    {
      tss <- genes.of.interest$start[i]
      if(tss > 1000)
      {
        promoter.seqs[[i]] <-current.seq[[1]][(tss-1000):(tss-1)]  
      } else
      {
        promoter.seqs[[i]] <-current.seq[[1]][1:(tss-1)]
      }
      
    } else if (current.strand == "-")
    {
      tss <- genes.of.interest$end[i]
      promoter.seqs[[i]] <- comp(rev(current.seq[[1]][(tss+1):(tss+1000)]))
    }
  }
  
  write.fasta(sequences = promoter.seqs,
              names = names(promoter.seqs),
              file.out = file.name)
  return(promoter.seqs)
}

```

For example, it was used with the carotenoids biosynthesis key enzime genes. 

```{r, echo = TRUE, eval = TRUE}

carotenoids.genes <- c("HaLaN_05222", "HaLaN_06917", "HaLaN_19207", "HaLaN_29333", "HaLaN_01499", "HaLaN_15035",
                       "HaLaN_05151", "HaLaN_15758", "HaLaN_04875")

promoter.sequence(genes.names = carotenoids.genes, 
                  genes.info = hlacustris.genes , 
                  genome.seqs = hlacustris.seqs,
                  file.name ="carotenoids_promoters.fa")

```


